///////////////////////////////////////////////////////////////////////////////
//MAIN.c
///////////////////////////////////////////////////////////////////////////////
int	g_exit = 0;

void	signal_handler(int sig) //certain signals are received.
{
	(void)sig; //suppresses any unused variable warnings for the sig parameter
	write(STDOUT_FILENO, "\n", 1); //writes a newline character ("\n") to the standard output, effectively printing a newline.
	rl_on_new_line(); //moves the readline library cursor to a new line
	rl_replace_line("", 0); //replaces the current line in the readline buffer with an empty string, effectively clearing the input line.
	rl_redisplay(); //refreshes and redisplays the readline prompt and buffer.
}

void	shell_loop(t_shell *shell) //is the main loop of the shell where the user interacts with the shell.
{
	t_pars	*command; //declares a pointer to a structure named command, which is used to store parsed command information.

	while (42) //runs indefinetely 
	{
		signal(SIGQUIT, SIG_IGN); // ignores the SIGQUIT signal (usually generated by pressing Ctrl+), preventing it from terminating the shell.
		signal(SIGINT, signal_handler); // sets up the SIGINT signal (usually generated by pressing Ctrl+C) to be handled by the signal_handler function defined earlier.
		shell->input = readline(shell->prompt); //reads a line of input from the user using the readline library and stores it in shell->input.
		if (!ft_strncmp(shell->input, "exit", 5) || shell->input == NULL) //checks if the user entered "exit" as the input or if they pressed Ctrl+D (indicating end-of-file).
			shell_exit(shell); // If true, it calls shell_exit(shell) to exit the shell.
		if (!ft_isvalid(shell->input)) //checks if the input is valid 
		{
			add_history(shell->input); // adds the input to the shell's command history.
			shell_parser(shell, &command); // parses the input using the shell_parser function and stores the result in the command structure.
			if (g_exit == 0) // checks if the global variable g_exit is set to 0 (indicating no exit command was executed).
				shell_executor(&command, shell);
		}
		pars_free(command);
		free(shell->input);
	}
}

void	shell_env(char **env, t_shell *shell) //This function sets up the shell's environment by processing the env array, which contains environment variables.
{
	int		i;
	char	**path_env; //double-pointer (string array) that will store substrings of the PATH environment variable

	i = 0;
	while (env[i]) // calculates the number of environment variables by counting the elements in the env array.
		i++; // 
	shell->env = (char **)ft_calloc(i + 1, sizeof(char *)); //allocates memory for an array of strings in shell->env
	i = -1; // reset variable to -1
	while (env[++i])
		shell->env[i] = ft_strdup(env[i]); // copies the environment variables from the env array to shell->env 
	i = 0; //reset to 0
	path_env = ft_split(getenv("PATH"), ':'); //splits the value of the PATH environment variable using the colon ':' as the delimiter and stores the resulting substrings in the path_env array.
	while (path_env[i]) //calculates the number of directories in the PATH by counting the elements in the path_env array.
		i++;
	shell->paths = (char **)ft_calloc(i + 1, sizeof(char *)); //allocates memory for an array of strings in shell->paths
	i = -1;
	while (path_env[++i])// constructs the full directory paths by concatenating each directory from path_env with a trailing slash ("/") and stores them in shell->paths.
		shell->paths[i] = ft_strjoin(path_env[i], "/");
	i = 0; //reset
	while (path_env[i]) //
		free(path_env[i++]); // frees the memory allocated for the individual directory strings in path_env.
	free(path_env); //frees the memory allocated for the path_env array itself
}

void	shell_innit(t_shell *shell, char **env)
{
	char	*user;

	shell->in = dup(STDIN_FILENO); //duplicates the standard input file descriptor (usually 0) and stores it in shell->in. This allows the shell to restore the original standard input if it is redirected during command execution.
	shell->out = dup(STDOUT_FILENO); //duplicates the standard output file descriptor (usually 1) and stores it in shell->out. Similar to shell->in, this allows the shell to restore the original standard output if it is redirected.
	shell->pipe[0] = -2; // These values are used to indicate the absence of an active pipe
	shell->pipe[1] = -2; // These values are used to indicate the absence of an active pipe
	shell->status = 0; //sets the status field of the t_shell structure to 0, indicating that there is no previous command execution status to report
	user = ft_strjoin(PURPLE, getenv("USER")); //creates a string user by concatenating the color code "PURPLE" with the result of getenv("USER"), which retrieves the current user's username.
	shell->prompt = ft_strjoin(user, "@SmolShell" CLR_RMV " > "); //constructs the shell's prompt by concatenating the user string with the text "@SmolShell" and the color reset code "CLR_RMV". This creates a prompt that typically looks like "PurpleUsername@SmolShellColorReset > ".
	free(user); //frees the memory allocated for the user string since it's no longer needed.
	shell_env(env, shell); //initializes the shell's environment by calling the shell_env function, which sets up shell->env and shell->paths
}

int	main(int ac, char **av, char **env)
{
	t_shell	shell;

	(void)ac; //
	(void)av; // are used to suppress compiler warnings about unused ac and av parameters since they are not used in this program
	ft_printf("%sWelcome %s!%s\n", GREEN, getenv("USER"), CLR_RMV); //prints a welcoming message
	shell_innit(&shell, env);
	shell_loop(&shell);
	return (0);
}


///////////////////////////////////////////////////////////////////////////////
//PARSER.c
///////////////////////////////////////////////////////////////////////////////
void	shell_parser(t_shell *shell, t_pars **command)
{
	t_tok		*token;
	static int	n;
	int			i;
	char		**inputs;

	*command = NULL; // initializes command pointer to NULL-- command pointer is expected to hold a linked list of parsed command
	token = NULL; // initializes  to NULL-- token used to store tokenized input obtained from the lex_tokenizer
	n = 0; // keeps track of the number of token passed
	i = 0; // used to iterate through the input array
	inputs = input_split(shell); //split the user input into an array of strings. Each string in the inputs array represents a part of the user's command.
	while (inputs[i]) //iterate through each element if of the input array
	{
		lex_tokenizer(shell, inputs[i], &token, &n);
		pars_lstadd_back(command, pars_lstnew(i + 1));
		pars_commander(token, pars_lstlast(*command));
		tok_free(token);
		token = NULL;
		i++;
	}
	tok_free(token);
	lex_free_inputs(inputs);
}

///////////////////////////////////////////////////////////////////////////////
//LEXER.c
///////////////////////////////////////////////////////////////////////////////


void	lex_tokenizer(t_shell *shell, char *input, t_tok **token, int *id)
{
	t_lex	*lex;
	int		i;

	lex = (t_lex *)ft_calloc(1, sizeof(t_lex)); //allocates memory for the lex structure
	lex->state = STATE_NORMAL; //initializes various fields
	lex->type = -1;
	lex->len = 0;
	lex->shell = shell;
	i = 0;
	while (input[i] && lex->type != -2) //loop processes each character of the input string until the end of the string is reached or the lexer's type becomes -2. -2 is used to indicate the end of tokenization.
	{
		if (lex->state == STATE_NORMAL) // STATE_NORMAL == 0
			state_normal(input[i], lex, token, id);
		else if (lex->state == STATE_DOUBLE_QUOTE // STATE_DOUBLE_QUOTE == 1
			|| lex->state == STATE_SINGLE_QUOTE) //STATE_SINGLE_QUOTE == 2
			state_quotes(input[i], lex);
		else if (lex->state == STATE_DOLLAR_SIGN) // STATE_DOLLAR_SIGN == 3
			state_dollar(input[i], lex, token, id);
		else if (lex->state == STATE_DOLLAR_SIGN_DOUBLE_QUOTE) //STATE_DOLLAR_SIGN_DOUBLE_QUOTE == 4
			state_dollarquotes(input[i], lex, token, id);
		else if (lex->state == STATE_REDIRECT) //STATE_REDIRECT == 5
			state_redirect(input[i], lex, token, id);
		i++;
	}
	lex_tokenizer_end(lex, token, id);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////
///LEX_STATE_NORMAL.c
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void	state_normal_dollar(t_lex *lex)
{
	lex->buffer[lex->len] = '$';
	lex->len++;
	lex->start = lex->len;
	lex->state = STATE_DOLLAR_SIGN;
}


//In summary, the state_normal_space function is responsible for handling spaces encountered during lexical analysis.
//When a space is encountered, it ensures that any content in the buffer is tokenized before resetting the buffer to prepare for the next token.
//This helps tokenize input correctly, separating tokens by spaces.
void	state_normal_space(t_lex *lex, t_tok **token, int *id) //lex: A pointer to a t_lex structure representing the lexer's state. token: A pointer to a pointer for a token linked list. id: An identifier for tokens.
{
	if (lex->len > 0) // This check is used to determine if there's any content in the buffer that needs to be tokenized.
	{
		lex->buffer[lex->len] = '\0'; //It null-terminates the buffer by setting lex->buffer[lex->len] to '\0'. This is necessary to turn the content in the buffer into a valid C string.
		tok_lstadd(token, lex, id); // function to add the tokenized content in the buffer to the token linked list. The token is created from the data in lex, and id is used to identify the token.
		lex->len = 0; //resets the lex->len to 0, indicating that the buffer is now empty and ready to receive new content.
	}
}

void	state_normal(char c, t_lex *lex, t_tok **token, int *id) //c, which is the current character being processed, lex, a pointer to a t_lex structure that holds lexer state, token, a pointer to a pointer for a token linked list, and id, an identifier for tokens.
{
	//checks the value of c to determine how to handle it.
	if (c == ' ')
	{
		state_normal_space(lex, token, id);
	}
	else if (c == DOUBLE_QUOTE)
	{
		lex->state = STATE_DOUBLE_QUOTE; //indicating that a double-quoted string is being processed.
	}
	else if (c == SINGLE_QUOTE)
	{
		lex->state = STATE_SINGLE_QUOTE; //indicating that a single-quoted string is being processed.
	}
	else if (c == '$')
	{
		state_normal_dollar(lex);
	}
	else if (c == '>' || c == '<') //when the lexer encounters a '>' or '<' character
	{
		if (lex->len > 0) //checks if lex->len (the length of the current token in the buffer) is greater than 0 //If lex->len is greater than 0, it means that the lexer has collected characters for a current token
		{
			lex->buffer[lex->len] = '\0'; // In this case, the code completes the current token by adding a null-terminator ('\0') at the current position in the buffer. This effectively marks the end of the token.
			tok_lstadd(token, lex, id); //// Adding the current token to the token list
			lex->len = 0; //resetting the lenght
		}
		lex_append(c, lex); //// Appending the redirection operator to the buffer
		lex->state = STATE_REDIRECT; //transitioning to the redirection state //indicating that it's now processing a redirection operator.
	}
	else
		lex_append(c, lex);
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///LEX_STATE_QUOTE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void	state_quotes_single(char c, t_lex *lex) //function is responsible for processing characters inside single quotes 
{ 
	if (c == SINGLE_QUOTE) // c is a single quote (') //it means the end of the single-quoted section
		lex->state = STATE_NORMAL; //function transitions the lexer's state back to STATE_NORMAL. This indicates that the lexer is no longer inside single quotes.
	else //if c is not a single quote ('), it means the character is part of the content within single quotes
		lex_append(c, lex); //the function appends c to the lexer's buffer using the lex_append function
}

void	state_quotes_double(char c, t_lex *lex) //function is responsible for processing characters inside double quotes (")
{
	if (c == DOUBLE_QUOTE) //if the character c is a double quote ("), it means the end of the double-quoted section.
	{
		lex->state = STATE_NORMAL; //transitions the lexer's state back to STATE_NORMAL, indicating that the lexer is no longer inside double quotes
	}
	else if (c == '$') //($), it may indicate the start of a variable substitution within double quotes
	{
		lex->buffer[lex->len] = '$'; // the function appends the dollar sign to the lexer's buffer
		lex->len++; //increments the length (len)
		lex->start = lex->len; // set the start position to the current lenght
		lex->state = STATE_DOLLAR_SIGN_DOUBLE_QUOTE; //transitions the lexer's state to STATE_DOLLAR_SIGN_DOUBLE_QUOTE // ?? This state is used to handle variable substitution within double quotes.
	}
	else // If c is neither a double quote nor a dollar sign, it means it's part of the content within double quotes.
		lex_append(c, lex); //function appends c to the lexer's buffer using the lex_append function
}

void	state_quotes(char c, t_lex *lex) // function serves as a dispatcher calls the appropriate handler function (state_quotes_double or state_quotes_single) depending on the state.
{
	if (lex->state == STATE_DOUBLE_QUOTE)
		state_quotes_double(c, lex);
	else if (lex->state == STATE_SINGLE_QUOTE)
		state_quotes_single(c, lex);
}



///////////////////////////////////////////////////////////////////////////////
//PIPE_SPLIT.c
///////////////////////////////////////////////////////////////////////////////
int	pipe_numstr(const char *s, char pipe)
{
	size_t	i; //Keeps track of the current position in the string s.
	size_t	n; //Stores the count of pipe characters found.
	size_t	len; //Tracks the length of consecutive characters encountered before a pipe or the end of the string.
	char	quote; //Stores the type of quote (single or double) if encountered

	i = 0;
	n = 0;
	len = 0;
	while (1) //infinite loop to traverse the input string
	{
		if (s[i] == pipe || s[i] == '\0') //Check if the current character (s[i]) is either the pipe character or the end of the string ('\0').
		{								  //if the character is a pipe or the end of the string
			if (len > 0)//If the length of characters seen before this point (len) is greater than 0; 
				n++;	//increment the count (n) because this indicates a pipe character was found.
			len = 0;	//Reset the length (len) to 0 to start counting characters for the next segment
		}
		if (s[i] == pipe && n == 0) //Check if a pipe character is encountered at the beginning of the string (when n == 0)
			return (-1); //If so, return -1, indicating an error because a pipe cannot start a command.
		else if (s[i] == DOUBLE_QUOTE || s[i] == SINGLE_QUOTE) //NOW HERE it checks for unmatched quotes
		{
			quote = s[i]; //Set quote to the current character (either " or ')
			i++; //  Move to the next character
			while (s[i] && s[i] != quote) //Start a loop that continues as long as the current character is not the same as the opening quote character and the current character is not the end of the string ('\0').
				i++; //Increment the position to move to the next character.
			if (s[i] == '\0') //Check if the loop exited because it reached the end of the string ('\0').
				break ; //If the loop exited because it reached the end of the string, break out of the enclosing loop
		}
		else //If none of the above conditions are met, increment the len variable to keep track of consecutive characters.
			len++;
		if (s[i] == '\0') //Check if the end of the string is reached.
			break ; // If so, break out of the loop
		i++; //Increment the position i to process the next character in the string.
	}
	return (n); //After exiting the loop, return the count n, which represents the number of pipe characters found in the string.
	//how does it exits??
}





///////////////////////////////////////////////////////////////////////////////
//LEXER_INIT
///////////////////////////////////////////////////////////////////////////////

t_tok	*tok_lstnew(t_lex *lexer, int *id)
{
	t_tok	*new;

	new = (t_tok *)ft_calloc(1, sizeof(t_tok)); //allocate memory for a new token
	if (new == NULL)
		return (NULL);
	new->id = ++(*id); //assigns an unique identifier //The id parameter is a pointer to an integer, and ++(*id) increments the value pointed to by id and assigns it to the id field of the new token. This ensures that each token has a unique identifier.
	if (lexer->type == REDIRECT) // It checks if the lexer's type field is REDIRECT
		new->type = lexer->type; // If it is, the new token's type field is set to REDIRECT
	else //otherwise
		new->type = lex_type(lexer->buffer, lexer->shell);//calls the lex_type function to determine the token's type based on the contents of the lexer's buffer.
	new->token = ft_strdup(lexer->buffer);//copies the token string from the lexer's buffer to the new token's token field
	new->next = NULL; //initialized to NULL for the moment
	new->prev = NULL; //initialized to NULL for the moment
	return (new); //returns a pointer to the newly created token
}

t_tok	*tok_lstlast(t_tok *token)//This function finds the last token in a linked list of tokens. //takes the head of the token list as input
{
	t_tok	*next; //

	if (token != NULL)
	{
		next = token; //pointer initialized  to the head of the list
		while (1) //iterates through the list
		{
			if (next->next == NULL) //until it finds the last token (where next->next == NULL). // EXAMPLE:  //Suppose we have a linked list of tokens: token1 -> token2 -> token3 -> NULL. When we call tok_lstlast(token1), it will return a pointer to token3, which is the last token in the list
				return (next);
			next = next->next;
		}
	}
	return (NULL);
}

void	tok_lstadd_back(t_tok **token, t_tok *new) //It takes a pointer to a pointer to the head of the token list (token) and a pointer to the new token (new).
{
	t_tok	*last;

	if (!token) //It checks if token is valid and whether the list is empty.
		return ;
	if (*token == NULL) //If the list is empty (*token is NULL)
		*token = new; //it sets the head of the list to the new token (*token = new)
	else //If the list is not empty
	{
		last = tok_lstlast(*token); //it finds the last token using tok_lstlast
		if (last != NULL)
		{
			last->next = new;
			new->prev = last; //appends the new token to the end by updating the next and prev pointers. (? ma Ã¨ giusto cosi'?)
		}
	}
}

void	tok_lstadd(t_tok **token, t_lex *lexer, int *id) //responsible for adding a new token to the end of a linked list of tokens //It takes as input a pointer to a pointer to the head of the token list (t_tok **token), a pointer to a lexer structure (t_lex *lexer), and a pointer to an integer identifier (int *id).
{
	tok_lstadd_back(token, tok_lstnew(lexer, id)); //calls the tok_lstnew function to allocate memory for a new token and initialize its fields based on the provided lexer and identifier.
}
