
int	g_exit = 0;

void	signal_handler(int sig) //certain signals are received.
{
	(void)sig; //suppresses any unused variable warnings for the sig parameter
	write(STDOUT_FILENO, "\n", 1); //writes a newline character ("\n") to the standard output, effectively printing a newline.
	rl_on_new_line(); //moves the readline library cursor to a new line
	rl_replace_line("", 0); //replaces the current line in the readline buffer with an empty string, effectively clearing the input line.
	rl_redisplay(); //refreshes and redisplays the readline prompt and buffer.
}

void	shell_loop(t_shell *shell) //is the main loop of the shell where the user interacts with the shell.
{
	t_pars	*command; //declares a pointer to a structure named command, which is used to store parsed command information.

	while (42) //runs indefinetely 
	{
		signal(SIGQUIT, SIG_IGN); // ignores the SIGQUIT signal (usually generated by pressing Ctrl+), preventing it from terminating the shell.
		signal(SIGINT, signal_handler); // sets up the SIGINT signal (usually generated by pressing Ctrl+C) to be handled by the signal_handler function defined earlier.
		shell->input = readline(shell->prompt); //reads a line of input from the user using the readline library and stores it in shell->input.
		if (!ft_strncmp(shell->input, "exit", 5) || shell->input == NULL) //checks if the user entered "exit" as the input or if they pressed Ctrl+D (indicating end-of-file).
			shell_exit(shell); // If true, it calls shell_exit(shell) to exit the shell.
		if (!ft_isvalid(shell->input)) //checks if the input is valid 
		{
			add_history(shell->input); // adds the input to the shell's command history.
			shell_parser(shell, &command); // parses the input using the shell_parser function and stores the result in the command structure.
			if (g_exit == 0) // checks if the global variable g_exit is set to 0 (indicating no exit command was executed).
				shell_executor(&command, shell);
		}
		pars_free(command);
		free(shell->input);
	}
}

void	shell_env(char **env, t_shell *shell) //This function sets up the shell's environment by processing the env array, which contains environment variables.
{
	int		i;
	char	**path_env; //double-pointer (string array) that will store substrings of the PATH environment variable

	i = 0;
	while (env[i]) // calculates the number of environment variables by counting the elements in the env array.
		i++; // 
	shell->env = (char **)ft_calloc(i + 1, sizeof(char *)); //allocates memory for an array of strings in shell->env
	i = -1; // reset variable to -1
	while (env[++i])
		shell->env[i] = ft_strdup(env[i]); // copies the environment variables from the env array to shell->env 
	i = 0; //reset to 0
	path_env = ft_split(getenv("PATH"), ':'); //splits the value of the PATH environment variable using the colon ':' as the delimiter and stores the resulting substrings in the path_env array.
	while (path_env[i]) //calculates the number of directories in the PATH by counting the elements in the path_env array.
		i++;
	shell->paths = (char **)ft_calloc(i + 1, sizeof(char *)); //allocates memory for an array of strings in shell->paths
	i = -1;
	while (path_env[++i])// constructs the full directory paths by concatenating each directory from path_env with a trailing slash ("/") and stores them in shell->paths.
		shell->paths[i] = ft_strjoin(path_env[i], "/");
	i = 0; //reset
	while (path_env[i]) //
		free(path_env[i++]); // frees the memory allocated for the individual directory strings in path_env.
	free(path_env); //frees the memory allocated for the path_env array itself
}

void	shell_innit(t_shell *shell, char **env)
{
	char	*user;

	shell->in = dup(STDIN_FILENO); //duplicates the standard input file descriptor (usually 0) and stores it in shell->in. This allows the shell to restore the original standard input if it is redirected during command execution.
	shell->out = dup(STDOUT_FILENO); //duplicates the standard output file descriptor (usually 1) and stores it in shell->out. Similar to shell->in, this allows the shell to restore the original standard output if it is redirected.
	shell->pipe[0] = -2; // These values are used to indicate the absence of an active pipe
	shell->pipe[1] = -2; // These values are used to indicate the absence of an active pipe
	shell->status = 0; //sets the status field of the t_shell structure to 0, indicating that there is no previous command execution status to report
	user = ft_strjoin(PURPLE, getenv("USER")); //creates a string user by concatenating the color code "PURPLE" with the result of getenv("USER"), which retrieves the current user's username.
	shell->prompt = ft_strjoin(user, "@SmolShell" CLR_RMV " > "); //constructs the shell's prompt by concatenating the user string with the text "@SmolShell" and the color reset code "CLR_RMV". This creates a prompt that typically looks like "PurpleUsername@SmolShellColorReset > ".
	free(user); //frees the memory allocated for the user string since it's no longer needed.
	shell_env(env, shell); //initializes the shell's environment by calling the shell_env function, which sets up shell->env and shell->paths
}

int	main(int ac, char **av, char **env)
{
	t_shell	shell;

	(void)ac; //
	(void)av; // are used to suppress compiler warnings about unused ac and av parameters since they are not used in this program
	ft_printf("%sWelcome %s!%s\n", GREEN, getenv("USER"), CLR_RMV); //prints a welcoming message
	shell_innit(&shell, env);
	shell_loop(&shell);
	return (0);
}
